<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>SaliCAD Скрипт для описания 3d моделей</title>
  </head>
  <body>
    <h1 align="center">Скрипт для описания 3d моделей</h1>
    <p><a href="contents.htm">Содержание</a>=&gt;Скрипт 3d</p>
    <p>Скриптовый язык для описания 3d моделей представляет C-подобный язык
      сценариев, предназначенный для параметрического построения 3d и 2d моделей
      корпусов компонентов. Скрипт создает некий шаблон конструкции (модель и 2d
      изображение компонента), который можно изменить в некоторых пределах
      (определяемых разработчиком скрипта) с тем, чтобы получить конкретную
      модель компонента.</p>
    <p>Изменяемые параметры конструкции задаются пользователем в диалоговом
      режиме. При этом сценарий пересчитывается заново и отображается вариант с
      внесенными изменениями. Например, форма корпуса компонента задается
      шаблоном (вертикальный цилиндр для штыревого конденсатора), а диаметр и
      высота цилиндра задаются пользователем. При этом будет построен цилиндр с
      параметрами пользователя. Аналогичным образом производятся и другие
      изменения: от цветов компонента, до количества ножек и контактных площадок
      под них.</p>
    <p>См. <a href="script3dFun.htm">перечень функций</a></p>
    <p>Скриптовый язык поддерживает следующие типы объектов:</p>
    <ul>
      <li><a href="script3dTypeBool.htm">логический</a></li>
      <li><a href="script3dTypeFloat.htm">числа</a> с плавающей точкой</li>
      <li><a href="script3dTypeColor.htm">цвета</a></li>
      <li><a href="script3dTypeString.htm">строки</a></li>
      <li><a href="script3dType2d.htm">2d объекты</a> (линия, прямоугольник,
        окружность, ножка)</li>
      <li><a href="script3dTypeMatrix.htm">матрица 4x4</a></li>
      <li><a href="script3dTypeFloatList.htm">список чисел</a> с плавающей
        точкой</li>
      <li><a href="script3dTypeVertex.htm">3d вершины</a></li>
      <li><a href="script3dTypeFace.htm">поверхность</a></li>
      <li><a href="script3dTypeFaceList.htm">список поверхностей</a></li>
      <li><a href="script3dTypeModel.htm">модель</a></li>
    </ul>
    <p>Любой из указанных типов может быть возвращен функцией.</p>
    <p>Кроме того, строки и числа, логические значения можно задавать
      непосредственно.</p>
    <p>Логические типы получаются как результаты операций сравнения.</p>
    <p>Остальные объекты конструируются с помощью функций из простых объектов
      или в результате преобразования.</p>
    <p>Скрипт выполняется последовательно оператор за оператором, начиная с
      первой строки. </p>
    <p>Символ # отмечает начало коментария. Все, что находится в строке после
      данного символа - игнорируется.</p>
    <p>Имеются следующие типы операторов:</p>
    <ul>
      <li>оператор присвания</li>
      <li>условный оператор</li>
      <li>оператор цикла</li>
      <li>составной оператор</li>
    </ul>
    <p>Практически вся реальная работа осуществляется с помощью встроенных
      функций. Различные арифметические действия используются как
      вспомогательные в этих построениях.<br>
    </p>
    <p>Типичный скрипт представлен ниже:</p>
    <code> bodyDiametr = inputFloat( "Body diametr", 4 )<br>
      bodyHeight = inputFloat( "Body height", 4 )<br>
      bodyColor = inputColor( "Body color", colorFromString("#4e9a06") )<br>
      <br>
      pinDiametr = inputFloat( "Pin diametr", 0.5 )<br>
      pinDistance = inputFloat( "Distance between pins", 2.5 )<br>
      pinColor = inputColor( "Pin color", colorFromString("#f0f0f0") )<br>
      <br>
      padPlus = inputPad( "Pad plus",
      stringPadRectThrough(1.0,1.0,pinDiametr*1.2,0.1) )<br>
      padMinus = inputPad( "Pad minus", "c1.2d0.6m0.1" )<br>
      <br>
      plusShow = inputFloat( "Show plus", 0 )<br>
      <br>
      bodyRadius = bodyDiametr / 2<br>
      <br>
      body = modelCylinder( bodyRadius, bodyHeight, bodyColor )<br>
      <br>
      pin = modelCylinder( pinDiametr / 2, -2.0, pinColor )<br>
      <br>
      partModel = body<br>
      <br>
      pinPlusPos = vertex( -pinDistance / 2, 0, 0 )<br>
      pinMinusPos = vertex( pinDistance / 2, 0, 0 )<br>
      <br>
      partModel = modelTranslate( pin, pinPlusPos )<br>
      <br>
      partModel = modelTranslate( pin, pinMinusPos )<br>
      <br>
      partFlat = graphCircle( vertex(0,0,0), bodyRadius )<br>
      <br>
      partFlat = graphPin( pinPlusPos, padPlus, vertexOffset( pinPlusPos,
      0,0,0), "1", "CM0", vertexOffset(pinPlusPos, 0,0,0), "CM0" )<br>
      <br>
      partFlat = graphPin( pinMinusPos, padMinus, vertexOffset( pinMinusPos,
      0,0,0), "2", "CM0", vertexOffset(pinMinusPos, 0,0,0), "CM0" )<br>
      if( plusShow &gt; 0 ) {<br>
      &nbsp; #Draw plus sign<br>
      &nbsp; plusCenter = vertex( -bodyRadius - 2, 0, 0 )<br>
      &nbsp; plusV0 = vertexOffset( plusCenter, 0, -1, 0 )<br>
      &nbsp; plusV1 = vertexOffset( plusCenter, 0, 1, 0 )<br>
      &nbsp; partFlat = graphLine( plusV0, plusV1 )<br>
      <br>
      &nbsp; plusV0 = vertexOffset( plusCenter, -1, 0, 0 )<br>
      &nbsp; plusV1 = vertexOffset( plusCenter, 1, 0, 0 )<br>
      &nbsp; partFlat = graphLine( plusV0, plusV1 )<br>
      &nbsp; }<br>
    </code>
    <p><br>
    </p>
    <p>Из листинга видно, что программа состоит из последовательности
      операторов. Операторы присваивания присваивают значение справа от знака =
      переменной слева от этого знака. Тип переменной определяется автоматически
      исходя из значения справа от знака =. Знак ; после оператора присваивания
      не обязателен.</p>
    <p>Имена переменных должны начинаться с буквы и должны состоять из букв и
      цифр. В именах допускаются буквы национальных алфавитов.</p>
    <p>Две специальные переменные partModel и partFlat используются для
      размещения моделей и 2d объектов в корпусе компонента. При проведении
      присваивания данным переменным модели и 2d объекты накапливаются в
      корпусе.</p>
    <p>Функции, имена которых начинаются на input служат для размещения
      параметра в таблице параметров скрипта для ввода пользователем. Остальные
      функции служат для различного преобразования данных. Полный список
      доступных функции см. <a href="script3dFun.htm">перечень функций</a>.</p>
    <p>Оператор цикла выглядит следующим образом:</p>
    <code>while( условие_цикла ) {<br>
      &nbsp; операторы_цикла<br>
      &nbsp; }<br>
    </code>
    <p>Пока выражение условие_цикла истинно цикл будет выполнять
      операторы_цикла. Например, код</p>
    <code>pinIndex = 0<br>
      while( pinIndex &lt; 4 ) {<br>
      &nbsp; pinIndex = pinIndex + 1<br>
      &nbsp; }<br>
    </code>
    <p>заставит тело цикла выполниться 4 раза.<br>
    </p>
    <p>Операция [список] формирует сложный объект из списка более простых
      объектов:</p>
    <ul>
      <li>из списка точек формируется поверхность</li>
      <li>из списка поверхностей формируется модель</li>
      <li>список чисел используется для построения поверхностей, а также как
        набор индексов</li>
    </ul>
    <p>Например, код</p>
    <code>vertex0 = vertexBuild( 0, 0, 0 )<br>
      vertex1 = vertexBuild( 10, 0, 0 )<br>
      vertex2 = vertexBuild( 10, 10, 0 )<br>
      vertex3 = vertexBuild( 0, 10, 0 )<br>
      face0 = [vertex0, vertex1, vertex2, vertex3]<br>
    </code>
    <p>строит поверхность из четырех предварительно сформированных вершин.<br>
    </p>
    <h2 align="center">3d модели</h2>
    <p>Основой построения моделей является точка в пространстве, которая
      представляет собой вершину замкнутой ломаной, ограничивающей поверхность.
      Таким образом, поверхность строится из набора вершин.</p>
    <img src="3dFace.png">
    <p>Вершина представляет собой три координаты точки X, Y и Z. Для построения
      вершины используется функция vertex, в параметрах которой указываются три
      координаты. Например:</p>
    <code>v0 = vertex( 10, 11, 12 )</code>
    <p><br>
    </p>
    <img src="3dFaceModel.png">
    <p><br>
    </p>
    <p>Поверхность состоит из трех и более вершин. Построить поверхность можно
      создать путем перечесления вершин, например:</p>
    <code>face0 = [ v0, v1, v2 ]</code>
    <p>где v0, v1 и v2 - переменные вершин.</p>
    <p>Более быстрый способ построения поверхностей по координатам - построение
      в 2d плоскости с последующим преобразованием. Это делается с помощью
      функции faceFlatMatrix.</p>
    <p>Поверхности объединяются в списки поверхностей (Face list). Списки
      поверхностей вместе с цветами их отображения составляют тело (Body). Все
      поверхности тела отображаются общим цветом.</p>
    <p>Тела объединяются в списки тел. Список тел вместе со списком матриц
      копирования представляет собой модель. Список матриц копирования модели
      должен содержать как минимум одну матрицу. Список тел модели также должен
      содержать как минимум одно тело.</p>
    <img src="3dModel.png">
    <p>Пример тела - корпус микросхемы. Поскольку весь корпус микросхемы
      отображается одним цветом, то все поверхности корпуса входят в одно тело.
      Поскольку корпус микросхемы всегда один, то модель содержит всего одну
      матрицу копирования для тела корпуса.</p>
    <p>Другой пример тела - вывод микросхемы (ножка). Ножка также отображается
      одним цветом, соответственно все поверхности ножки входят в одно тело. Так
      как ножек может быть несколько, то модель будет содержать столько матриц
      копирования, сколько одинаковых ножек у микросхемы.</p>
    <p>Еще пример тела - одинарный разъем типа pls. Модель этого разъема будет
      содержать два тела: пластиковое основание и штырек. Количество матриц
      копирования определяется количеством выводов такого разъема.</p>
    <p>Модели строятся с помощью функций modelXXX. Набор функций modelXXX
      содержит в себе основную функцию построения модели model, а также две
      функции модификации модели modelAppend и modelCopy. Функция model строит
      модель на основе списка поверхностей и цветом для этих поверхностей, а
      также матрицы копирования. Из списка поверхностей и цветов формируется
      тело и помещается в список тел модели, матрица копирования добавляется в
      список матриц копирования. Таким образом, эта функция строит модель из
      одного тела с одной матрицей копирования. Функция modelAppend служит для
      добавления к модели очередного тела. Функция modelCopy служит для
      добавления к модели очередной матрицы копирования.</p>
    Список поверхностей состоит из одной и более поверхностей. Помимо прямого
    создания поверхностей по вершинам, существует целый набор функций для
    генерации поверхностей.<br>
    <h2 align="center">Генерация поверхностей</h2>
    <p><br>
    </p>
  </body>
</html>
